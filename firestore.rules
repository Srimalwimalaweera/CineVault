
/**
 * This ruleset enforces a security model for the CineVault application, which
 * manages a public collection of videos and private, user-specific data like
 * favorites and playlists.
 *
 * Core Philosophy:
 * The security model is built on two key principles:
 * 1. Public Read, Admin Write: A central collection of videos is readable
 *    by anyone to allow for browsing. However, all modifications (create, update,
 *    delete) to this collection are restricted to administrative users.
 * 2. Strict User Ownership: All user-generated content (profiles, favorites,
 *    playlists) is stored in a path dedicated to that user (`/users/{userId}`).
 *    Access is strictly limited to the authenticated user who owns that data,
 *    preventing users from accessing or modifying each other's private data.
 *
 * Data Structure:
 * - /videos/{videoId}: Public video metadata.
 * - /users/{userId}: Public user profiles.
 * - /users/{userId}/favorites/{favoriteId}: A user's private list of favorites.
 * - /users/{userId}/playlists/{playlistId}: A user's private video playlists.
 *
 * Key Security Decisions:
 * - Admin Role for Content Management: Write operations on `/videos` are
 *   protected by checking the user's role in their profile document.
 * - Path-Based Ownership: User data is secured by matching the authenticated
 *   user's UID against the `{userId}` wildcard in the document path.
 * - User Profile Security: Users can create and update their own profiles but
 *   are prevented from assigning themselves the 'admin' role or altering
 *   their creation timestamp.
 * - No Global User Listing: The rules do not allow listing the entire `/users`
 *   collection to prevent enumeration of all application users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Validates if the requesting user is the owner of a document based on a userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user has administrative privileges by reading their user document.
     * Note: This is less performant than using custom claims but suitable for development.
     */
    function isDbAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Validates that a user is not attempting to change their role.
     */
    function isRoleImmutable() {
      return request.resource.data.role == resource.data.role;
    }

    /**
     * Validates that the role being assigned during creation is 'user'.
     */
    function isRoleUserOnCreate() {
        return request.resource.data.role == 'user';
    }


    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Publicly readable video metadata. Writes are restricted to admins.
     * @path /videos/{videoId}
     */
    match /videos/{videoId} {
      allow read: if true;
      allow write: if isDbAdmin();
    }

    /**
     * @description User profile data.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow read: if isOwner(userId) || isDbAdmin();
      allow create: if isOwner(userId) && isRoleUserOnCreate();
      allow update: if isOwner(userId) && isRoleImmutable();
      // Deleting user profiles is disabled to maintain data integrity.
      allow delete: if false;
    }


    /**
     * @description A user's private collection of favorite videos.
     * @path /users/{userId}/favorites/{favoriteId}
     */
    match /users/{userId}/favorites/{favoriteId} {
      allow read, write: if isOwner(userId);
    }

    /**
     * @description A user's private collection of video playlists.
     * @path /users/{userId}/playlists/{playlistId}
     */
    match /users/{userId}/playlists/{playlistId} {
      allow read, write: if isOwner(userId);
    }
  }
}
